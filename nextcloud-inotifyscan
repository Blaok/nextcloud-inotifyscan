#!/usr/bin/python
from __future__ import print_function

import argparse
import atexit
import collections
import fcntl
import logging
import os
import signal
import subprocess
import sys
import time

try:
  import configparser
except ImportError:
  import ConfigParser as configparser

logging.basicConfig(format='%(levelname)s - %(message)s')
_logger = logging.getLogger()

Instance = collections.namedtuple('Instance', 'interval occ user docker')
Task = collections.namedtuple('Task', 'interval occ_cmd paths')

class EnvironNotFound(Exception):
  pass

def parse_config(config_file):
  """Parse the give config file and yield Instance objects.
  """
  try:
    config = configparser.ConfigParser()
    config.readfp(config_file)
  except configparser.Error as e:
    _logger.fatal('config error: %s', e)
  for section in config.sections():
    try:
      interval = config.getfloat(section, 'interval')
      occ = config.get(section, 'occ')
      users = config.get(section, 'user').split(',')
      try:
        docker = config.getboolean(section, 'docker')
      except ValueError:
        docker = config.get(section, 'docker').split(':')
        if len(docker) != 2:
          _logger.warning('docker must be specified as `username:container`')
          continue
      for user in map(str.strip, users):
        yield Instance(interval=interval, occ=occ, user=user, docker=docker)
    except configparser.Error as e:
      _logger.warning('config error: %s', e)

def parse_environ():
  """Parse the environment variables and return an Instance object.
  """
  def require_environ(var):
    if var not in os.environ:
      raise EnvironNotFound('environment variable %s is not set' % var)
    return os.environ[var]

  interval = float(os.environ.get('INTERVAL', 1.))
  user = require_environ('USER_NAME').strip()
  if os.environ.get('USE_DOCKER') == 'True':
    docker = [require_environ('DOCKER_USER'),
              require_environ('DOCKER_CONTAINER')]
    occ = 'occ'
  else:
    docker = False
    occ = require_environ('NEXTCLOUD_HOME') + '/occ'
  return Instance(interval=interval, occ=occ, user=user, docker=docker)

def parse_args():
  """Parse commandline arguments and yield Instance objects.
  """
  parser = argparse.ArgumentParser(description='nextcloud inotifyscan')
  parser.add_argument('-c', '--config', type=argparse.FileType('r'),
                      help='optional config file')
  parser.add_argument('-v', '--verbose', action='count',
                      help='increase logging verbosity')
  parser.add_argument('-q', '--quiet', action='count',
                      help='decrease logging verbosity')
  args = parser.parse_args(sys.argv[1:])

  verbosity = 0
  if args.verbose is not None:
    verbosity += args.verbose
  if args.quiet is not None:
    verbosity -= args.quiet
  if verbosity > 0:
    _logger.setLevel(logging.DEBUG)
  elif verbosity == 0:
    _logger.setLevel(logging.INFO)
  elif verbosity == -1:
    _logger.setLevel(logging.WARNING)
  elif verbosity == -2:
    _logger.setLevel(logging.ERROR)
  else:
    _logger.setLevel(logging.CRITICAL)

  try:
    yield parse_environ()
  except EnvironNotFound:
    pass

  if args.config is not None:
    for instance in parse_config(args.config):
      yield instance

def cleanup(proc):
  proc.kill()

def scan(task):
  """Scan all paths with given the interval and occ command.
  """
  for p in task.paths:
    _logger.info('Scan for %s', p)
    subprocess.call(task.occ_cmd+['files:scan', '--no-interaction', '--path='+p,
                                  '--shallow', '--quiet'])
  task.paths.clear()

def watch_instances(instances):
  """Setup inotifywait for the given instances and yield tasks.
  """
  instances = tuple(instances)
  workers = [watch(instance) for instance in instances]
  min_interval = min(instance.interval for instance in instances)
  while True:
    interval = min_interval
    for worker in workers:
      task = next(worker)
      if task.paths:
        interval = None
        yield task
    if interval is not None:
      time.sleep(interval)

def watch(instance):
  """Setup inotifywait for the given instance and yield tasks.
  """
  interval, user_name = instance.interval, instance.user
  if instance.docker:
    occ_cmd = ['docker', 'exec', '-u'+instance.docker[0], instance.docker[1],
               'php', instance.occ]
  else:
    occ_cmd = ['php', instance.occ]
  data_prefix = subprocess.check_output(
      occ_cmd+['config:system:get', 'datadirectory'],
      universal_newlines=True).rstrip()
  data_prefix_len = len(data_prefix)
  scan_paths = set()
  inotifywait_proc = subprocess.Popen(
      ['inotifywait', '--event', 'create,modify,move,delete', '--exclude',
       r'/\.', '--recursive', data_prefix+'/'+user_name+'/files', '--quiet',
       '--format', '%e/%f%w/', '--monitor'],
      stdout=subprocess.PIPE, bufsize=0)
  atexit.register(cleanup, inotifywait_proc)
  inotifywait_fd = inotifywait_proc.stdout.fileno()
  inotifywait_fl = fcntl.fcntl(inotifywait_fd, fcntl.F_GETFL)

  while True:
    event = b''
    file_name = b''
    file_path = b''
    while True:
      fcntl.fcntl(inotifywait_fd, fcntl.F_SETFL, inotifywait_fl|os.O_NONBLOCK)

      try:
        c = inotifywait_proc.stdout.read(1)
        # Python 3 nothing read
        if c is None:
          yield Task(interval=interval, occ_cmd=occ_cmd, paths=scan_paths)
          continue
      # Python 2 nothing read
      except IOError:
        yield Task(interval=interval, occ_cmd=occ_cmd, paths=scan_paths)
        continue

      fcntl.fcntl(inotifywait_fd, fcntl.F_SETFL, inotifywait_fl)
      if c != b'/':
        event += c
      else:
        while True:
          c = inotifywait_proc.stdout.read(1)
          if c != b'/':
            file_name += c
          else:
            lastc = b''
            while True:
              lastlastc = lastc
              lastc = c
              c = inotifywait_proc.stdout.read(1)
              if c == b'\n' and lastc == b'/' and lastlastc == b'/':
                break
              else:
                file_path += lastc
            break
        break
    event = event.decode('utf-8')
    file_name = file_name.decode('utf-8')
    file_path = file_path.decode('utf-8')
    if set(event.split(',')) & {'CREATE', 'MODIFY'}:
      scan_path = file_path+file_name
    else:
      scan_path = file_path
    if data_prefix == scan_path[:data_prefix_len]:
      scan_path = scan_path[data_prefix_len:]
    _logger.info('Found %s %s %s', file_path, event, file_name)
    scan_paths |= {scan_path}

def main():
  signal.signal(signal.SIGINT, signal.default_int_handler)
  for task in watch_instances(parse_args()):
    scan(task)

if __name__ == '__main__':
  try:
    main()
  except KeyboardInterrupt:
    sys.exit(0)
